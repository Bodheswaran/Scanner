import subprocess
import sys
import os
import time

def install(package):
    """Install a package using pip."""
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])

def install_or_upgrade(setuptools_version=None):
    """
    Installs or upgrades setuptools.
    :param setuptools_version: Optional parameter to specify exact version.
                              Defaults to latest available.
    """
    if setuptools_version:
        cmd_args = [f"--upgrade={setuptools_version}", "--force-reinstall"]
    else:
        cmd_args = ['--upgrade']

    subprocess.run(['pip'] + cmd_args + ['setuptools'])

def check_pkg_resources_availability():
    """Check if pkg_resources is available."""
    try:
        import pkg_resources
        return True
    except ModuleNotFoundError:
        return False

def check_and_install_resources():
    """Check if pkg_resources is available, and install if not."""
    if not check_pkg_resources_availability():
        print("pkg_resources not found. Installing/upgrading setuptools...")
        install_or_upgrade()  

def check_rce_vulnerabilities():
    # Known vulnerable packages and their versions
    vulnerabilities = {
        'gitpython': '3.1.30'  # Versions prior to this are vulnerable
    }

    import pkg_resources  # Import here after ensuring it's available

    installed_packages = {pkg.key: pkg.version for pkg in pkg_resources.working_set}

    vulnerable_packages = []

    for package, vulnerable_version in vulnerabilities.items():
        if package in installed_packages:
            if installed_packages[package] < vulnerable_version:
                vulnerable_packages.append((package, installed_packages[package]))

    return vulnerable_packages

def assess_risk_level(issue):
    """Assess risk level based on the type of misconfiguration."""
    if "Hardcoded secret" in issue:
        return "High Risk"
    elif "Insecure permissions" in issue:
        return "Medium Risk"
    else:
        return "Low Risk"

def check_misconfigurations():
    """Scan the system for common misconfigurations."""
    misconfigurations = []

    # Check for hardcoded secrets in Python files
    for root, _, files in os.walk("/"):  # Scan the entire filesystem
        for file in files:
            if file.endswith(".py"):
                with open(os.path.join(root, file), 'r', errors='ignore') as f:
                    content = f.read()
                    if "API_KEY" in content or "SECRET" in content:  # Example keywords
                        misconfigurations.append(f"Hardcoded secret found in [{file}] at [{os.path.join(root, file)}]")

            # Check file permissions (example: sensitive files should not be world-readable)
            if file in ['config.py', '.env']:
                file_path = os.path.join(root, file)
                permissions = oct(os.stat(file_path).st_mode)[-3:]
                if permissions[0] == '7':  # Check if owner has read/write/execute permissions
                    misconfigurations.append(f"Insecure permissions on [{file_path}]: {permissions}")

            # Optionally, check for insecure HTTP headers (if applicable)
            # This would typically require web server access or specific application context.

    return misconfigurations

def main():
    start_time = time.time()  # Start timing

    print("Checking for required packages...")
    check_and_install_resources()

    print("Checking for Remote Code Execution vulnerabilities...")
    rce_vulnerabilities = check_rce_vulnerabilities()

    if rce_vulnerabilities:
        print("Vulnerable Packages Found:")
        for package, version in rce_vulnerabilities:
            print(f"Package: {package}, Installed Version: {version}")
    else:
        print("No known vulnerabilities found.")

    print("Checking for common misconfigurations...")
    misconfigurations = check_misconfigurations()

    if misconfigurations:
        print("Misconfigurations Found:")
        for issue in misconfigurations:
            risk_level = assess_risk_level(issue)
            print(f"{issue} - Risk Level: {risk_level}")
    else:
        print("No known misconfigurations found.")

    end_time = time.time()  # End timing
    elapsed_time = end_time - start_time  # Calculate elapsed time

    print(f"\nTotal time taken: {elapsed_time:.2f} seconds")
    
if __name__ == "__main__":
    main()
